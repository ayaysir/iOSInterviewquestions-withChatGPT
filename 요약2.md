# iOSInterviewquestions II

### ⛔️ 주의사항 
- 상황별 인터뷰 질문에 대한 ChatGPT의 요약본
- 답변의 방향을 정하고 답변 내용을 다듬는 용도로만 사용
- 의심가는 부분은 반드시 교차검증 필요
- 특히 경험과 관련된 답변(개인의 경험과 매우 동떨어져있을 수 있음), 2021년 이후 정보에 관한 답변은 반드시 경계

## iOS
**1. Bounds와 Frame의 차이점을 설명하시오.**
   - **답변:** Bounds는 뷰의 로컬 좌표 시스템에서 뷰의 영역을 나타내며, 원점(0,0)을 기준으로 크기와 위치를 나타냅니다. Frame은 부모 뷰의 좌표 시스템에서 뷰의 위치와 크기를 나타냅니다. 따라서 Bounds는 자기 자신을 기준으로 크기와 위치를 나타내고, Frame은 부모 뷰를 기준으로 나타냅니다.

**2. 실제 디바이스가 없을 경우 개발 환경에서 할 수 있는 것과 없는 것을 설명하시오.**
   - **답변:** 디바이스가 없을 경우 시뮬레이터를 사용하여 앱을 실행하고 디버깅할 수 있습니다. 하지만 실제 디바이스에서만 테스트 가능한 일부 기능(예: 카메라, 센서 등)은 시뮬레이터에서 테스트할 수 없습니다.

**3. 앱의 콘텐츠나 데이터 자체를 저장/보관하는 특별한 객체를 무엇이라고 하는가?**
   - **답변:** 앱의 콘텐츠나 데이터를 저장하고 관리하는 특별한 객체를 '데이터 모델'이라고 합니다.

**4. 앱 화면의 콘텐츠를 표시하는 로직과 관리를 담당하는 객체를 무엇이라고 하는가?**
   - **답변:** 앱 화면의 콘텐츠를 표시하고 관리하는 객체를 '뷰 컨트롤러(View Controller)'라고 합니다.

**5. App thinning에 대해서 설명하시오.**
   - **답변:** App thinning은 앱의 크기를 최적화하기 위한 기술로, 사용자의 디바이스에 맞게 필요한 리소스만 제공하는 방식입니다. 이는 앱을 다운로드하거나 업데이트할 때 불필요한 리소스를 제외하여 디바이스의 저장 공간을 절약하고 다운로드 시간을 단축시킵니다.

**6. 앱이 시작할 때 main.c에 있는 UIApplicationMain 함수에 의해서 생성되는 객체는 무엇인가?**
   - **답변:** UIApplicationMain 함수에 의해 생성되는 객체는 앱의 핵심 객체인 'UIApplication' 객체입니다.

**7. @Main에 대해서 설명하시오.**
   - **답변:** @main은 Swift에서 앱의 진입점을 지정하는 어트리뷰트로, 앱의 메인 진입 지점을 나타냅니다. 이는 앱의 실행이 시작되는 위치를 정의하는 역할을 합니다.

**8. 앱이 foreground에 있을 때와 background에 있을 때 어떤 제약사항이 있나요?**
   - **답변:** Foreground에 있을 때는 사용자와 상호작용이 가능하고 CPU 사용이 허용되지만, Background에 있을 때는 일부 동작이 제한되며 시스템의 에너지 효율성을 고려해야 합니다.

**9. 상태 변화에 따라 다른 동작을 처리하기 위한 앱 델리게이트 메서드들을 설명하시오.**
   - **답변:** `application(_:didFinishLaunchingWithOptions:)`, `applicationWillResignActive(_:)`, `applicationDidEnterBackground(_:)`, `applicationWillEnterForeground(_:)`, `applicationDidBecomeActive(_:)` 등이 있으며, 각 메서드는 앱의 상태 변화에 따라 호출되어 특정 동작을 수행합니다.

**10. 앱이 Inactive 상태가 되는 시나리오를 설명하시오.**
   - **답변:** 앱이 Inactive 상태로 전환되는 시나리오는 다른 앱이나 시스템 인터럽션으로 현재 앱의 사용자 상호작용이 중지되는 경우입니다.

**11. Scene delegate에 대해 설명하시오.**
   - **답변:** Scene delegate는 iOS 13부터 도입된 개념으로, 앱이 다중 창 환경에서 실행될 때 각 창에 대한 라이프사이클 이벤트를 처리하는 객체입니다.

**12. UIApplication 객체의 컨트롤러 역할은 어디에 구현해야 하는가?**
   - **답변:** UIApplication 객체의 컨트롤러 역할은 앱 델리게이트에 구현해야 합니다.

**13. App의 Not running, Inactive, Active, Background, Suspended에 대해 설명하시오.**
   - **답변:** 
      - Not running: 앱이 시작되지 않았거나 종료된 상태.
      - Inactive: 앱이 전면에 있지만 사용자와 상호작용이 불가능한 상태.
      - Active: 앱이 전면에 있고 사용자와 상호작용이 가능한 상태.
      - Background: 앱이 백그라운드에서 실행 중이며 일부 동작이 제한된 상태.
      - Suspended: 앱이 백그라운드에서 실행 중이지만 코드 실행이 중지된 상태.
      
**14. iOS 앱을 만들고, User Interface를 구성하는 데 필수적인 프레임워크 이름은 무엇인가?**
   - **답변:** iOS 앱의 User Interface를 구성하는 데 필수적인 프레임워크는 UIKit입니다.

**15. Foundation Kit은 무엇이고 포함되어 있는 클래스들은 어떤 것이 있는지 설명하시오.**
   - **답변:** Foundation Kit은 기본적인 데이터 구조, 파일 처리, 네트워킹 등을 지원하는 프레임워크입니다. 포함된 클래스로는 NSString, NSArray, NSDictionary, NSDate 등이 있습니다.

**16. Delegate란 무엇인지 설명하고, retain 되는지 안되는지 그 이유를 함께 설명하시오.**
   - **답변:** Delegate는 객체 간의 상호 작용을 위해 사용되는 디자인 패턴으로, 한 객체가 다른 객체를 대신하여 특정 동작이나 데이터를 처리할 수 있도록 하는 메커니즘입니다. 보통 retain cycle을 방지하기 위해 delegate는 weak 또는 unowned로 선언되며, 이는 상호 참조로 인한 메모리 누수를 방지하기 위함입니다.

**17. NotificationCenter 동작 방식과 활용 방안에 대해 설명하시오.**
   - **답변:** NotificationCenter는 발행-구독 패턴을 기반으로 동작하며, 이벤트 발생 시 등록된 Observer들에게 알립니다. 주로 앱 내에서 특정 이벤트 발생 시 다른 부분들 간에 통신하거나 데이터 전달에 활용됩니다.

**18. UIKit 클래스들을 다룰 때 꼭 처리해야하는 애플리케이션 쓰레드 이름은 무엇인가?**
   - **답변:** UIKit 클래스들은 주로 '메인 쓰레드(Main Thread)'에서 처리되어야 합니다.

**19. App Bundle의 구조와 역할에 대해 설명하시오.**
   - **답변:** App Bundle은 앱이 실행될 때 필요한 모든 리소스와 메타데이터를 담고 있는 디렉터리입니다. 이 디렉터리는 앱의 실행 파일, 이미지, 사운드 파일, 설정 파일 등을 포함하며, 앱의 배포와 실행에 필수적인 역할을 합니다.

**20. 모든 View Controller 객체의 상위 클래스는 무엇이고 그 역할은 무엇인가?**
   - **답변:** 모든 View Controller 객체의 상위 클래스는 'UIViewController'이며, 화면의 컨텐츠를 관리하고 해당 뷰와 상호 작용하는 데 필요한 메서드와 속성을 제공합니다.

**21. 자신만의 Custom View를 만들려면 어떻게 해야하는지 설명하시오.**
   - **답변:** 자신만의 Custom View를 만들려면 UIView를 상속하고, 필요한 메서드나 속성을 오버라이드하여 새로운 동작이나 모양을 정의해야 합니다.

**22. View 객체에 대해 설명하시오.**
   - **답변:** View 객체는 사용자 인터페이스의 구성 요소로, 화면에 보이는 모든 것을 나타냅니다. UIView 클래스의 인스턴스이며, 화면에 렌더링되는 요소들을 포함하고 사용자의 상호 작용에 응답할 수 있습니다.

**23. UIView에서 Layer 객체는 무엇이고 어떤 역할을 담당하는지 설명하시오.**
   - **답변:** UIView의 Layer 객체는 그래픽 콘텐츠를 그리고 애니메이션, 그림자 효과 등을 처리하는 데 사용됩니다. CALayer 클래스의 인스턴스이며, UIKit에서는 UIView를 통해 이에 접근할 수 있습니다.

**24. iOS에서 뷰(View)와 레이어(Layer)의 개념과 차이점에 대해 설명해보세요.**
   - **답변:** 뷰(View)는 사용자 인터페이스의 구성 요소를 나타내는 객체로, 화면에 보이는 모든 것을 포함합니다. 레이어(Layer)는 UIView의 내부적인 그래픽 처리를 담당하며, 뷰의 시각적인 콘텐츠를 그리고 애니메이션 등을 처리합니다.

**25. UIWindow 객체의 역할은 무엇인가?**
   - **답변:** UIWindow 객체는 앱의 화면을 나타내며, 여기에 앱의 모든 콘텐츠가 표시됩니다. 모든 UIView 객체는 UIWindow 객체의 서브뷰로서 표시됩니다.

**26. UINavigationController의 역할이 무엇인지 설명하시오.**
   - **답변:** UINavigationController는 계층적인 내비게이션 인터페이스를 제공하며, 다양한 뷰 컨트롤러를 스택에 관리하여 앱의 화면 간에 쉽게 이동할 수 있도록 합니다.

**27. TableView를 동작 방식과 화면에 Cell을 출력하기 위해 최소한 구현해야 하는 DataSource 메서드를 설명하시오.**
   - **답변:** TableView는 데이터 소스(Data Source)를 통해 데이터를 제공받아 화면에 Cell을 출력합니다. UITableViewDataSource 프로토콜을 채택하여 최소한 `numberOfRowsInSection` 및 `cellForRowAt` 메서드를 구현해야 합니다.

**28. 하나의 View Controller 코드에서 여러 TableView Controller 역할을 해야 할 경우 어떻게 구분해서 구현해야 하는지 설명하시오.**
   - **답변:** 여러 TableView Controller 역할을 하는 경우, 각각의 역할에 따라 다른 데이터를 사용하고, UITableViewDelegate 및 UITableViewDataSource를 구현하여 각각의 특성에 맞게 동작하도록 구현합니다.

**29. setNeedsLayout와 setNeedsDisplay의 차이에 대해 설명하시오.**
   - **답변:** `setNeedsLayout`은 뷰의 레이아웃을 재구성하라는 표시이며, `setNeedsDisplay`는 뷰의 내용을 다시 그리라는 표시입니다.

**30. stackView의 장점과 단점에 대해서 설명하시오.**
   - **답변:** UIStackView는 뷰들을 간편하게 정렬하고 관리할 수 있는 장점이 있으나, 복잡한 레이아웃을 다루기에는 한계가 있을 수 있습니다. 복잡한 레이아웃이 필요한 경우에는 다른 방식의 레이아웃을 고려해야 합니다.
     
**31. NSCache와 딕셔너리로 캐시를 구성했을 때의 차이를 설명하시오.**
   - **답변:** NSCache와 딕셔너리 모두 키-값 형태의 데이터를 저장하는데 사용됩니다. 주된 차이는 NSCache는 자동으로 메모리 관리를 수행하면서 메모리 부족 시에 자동으로 캐시 항목을 제거하여 앱의 성능을 최적화합니다. 반면에 딕셔너리는 수동으로 메모리 관리를 해주어야 하며, 메모리 부족 시에는 개발자가 직접 항목을 삭제해주어야 합니다.

**32. URLSession에 대해서 설명하시오.**
   - **답변:** URLSession은 네트워크 데이터 전송을 관리하는 객체로, 데이터를 다운로드하거나 업로드하는 작업을 수행합니다. URLSession은 강력한 기능과 다양한 설정 옵션을 제공하여 네트워크 통신을 유연하게 다룰 수 있도록 합니다.

**33. prepareForReuse에 대해서 설명하시오.**
   - **답변:** `prepareForReuse`는 UITableViewCell이나 UICollectionViewCell이 재사용될 때 호출되는 메서드입니다. 이 메서드를 사용하여 셀의 상태를 초기화하거나 새로운 데이터로 업데이트할 수 있습니다.

**34. 다크모드를 지원하는 방법에 대해 설명하시오.**
   - **답변:** 다크모드를 지원하기 위해서는 Asset Catalog에서 각 이미지에 대한 라이트 및 다크 모드용 이미지를 제공해야 합니다. 또한, 색상 값을 동적으로 설정하는데에는 `traitCollectionDidChange` 메서드를 활용하여 현재 트레이트 컬렉션에 따라 UI를 업데이트할 수 있습니다.

**35. ViewController의 생명주기를 설명하시오.**
   - **답변:** ViewController의 생명주기에는 `viewDidLoad`, `viewWillAppear`, `viewDidAppear`, `viewWillDisappear`, `viewDidDisappear` 등이 포함되어 있습니다. ViewController가 생성되고 화면이 나타날 때, 사라질 때 등의 각각의 단계에서 특정 메서드들이 호출되어 초기화 또는 정리 작업을 수행합니다.

**36. TableView와 CollectionView의 차이점을 설명하시오.**
   - **답변:** TableView와 CollectionView는 모두 데이터의 목록을 표시하는 뷰이지만 주된 차이는 레이아웃 및 표시 방식에 있습니다. TableView는 단일 열로 된 목록을 표시하고, CollectionView는 다양한 레이아웃 및 다중 열을 지원하여 더 유연한 데이터 표시를 제공합니다.

**37. Dynamic Library와 Static Library의 차이점에 대해 설명해보세요.**
   - **답변:** Dynamic Library는 런타임 시에 앱에 동적으로 링크되어 사용되는 라이브러리이며, 앱 실행 파일이 더 가볍습니다. Static Library는 컴파일 시에 앱에 포함되어 앱 실행 파일이 더 커지지만, 런타임에 외부 라이브러리에 의존하지 않습니다. Dynamic Library는 여러 앱에서 공유되어 사용될 수 있지만, Static Library는 각 앱에 복사되어 독립적으로 동작합니다.

## Autolayout
**1. 오토레이아웃을 코드로 작성하는 방법은 무엇인가? (3가지)**
   - **답변:**
     1. NSLayoutConstraint 사용: `NSLayoutConstraint` 클래스를 사용하여 코드로 제약조건을 생성하고 뷰에 추가합니다.
     2. Visual Format Language (VFL) 사용: 문자열 기반의 VFL을 사용하여 제약을 간단하게 표현할 수 있습니다.
     3. Anchor 사용: 레이아웃 앵커(Anchor)를 활용하여 코드로 간결하게 제약을 설정할 수 있습니다.

**2. hugging, resistance에 대해서 설명하시오.**
   - **답변:** `Content Hugging Priority`는 뷰가 자신의 내용(content)을 얼마나 강하게 감출지를 나타내는 우선순위이고, `Content Compression Resistance Priority`는 뷰가 자신의 내용을 얼마나 강하게 압축에 저항할지를 나타내는 우선순위입니다.

**3. Intrinsic Size에 대해서 설명하시오.**
   - **답변:** `Intrinsic Size`는 뷰가 내부 콘텐츠의 크기에 따라 자동으로 결정되는 크기를 의미합니다. 예를 들어, UILabel은 텍스트의 길이와 내용에 따라 Intrinsic Content Size를 가지게 됩니다.

**4. 스토리보드를 이용했을 때의 장단점을 설명하시오.**
   - **답변:** 장점은 시각적으로 UI를 구성할 수 있어 개발 속도가 빨라지고, 디자이너와 협업이 용이하며, 간단한 UI 작업에 적합합니다. 단점은 복잡한 UI 구성이 어렵고 충돌이 발생할 수 있으며, 대규모 프로젝트에서는 유지보수가 어려울 수 있습니다.

**5. Safe Area에 대해서 설명하시오.**
   - **답변:** `Safe Area`는 화면의 가장자리에서 일정한 간격을 제공하는 영역으로, notch, 상태표시줄, 홈 버튼 등의 영향을 받지 않는 안전한 영역입니다. Safe Area를 사용하면 디바이스에 따라 UI가 안전하게 배치되어 다양한 화면 크기에 대응할 수 있습니다.

**6. Left Constraint와 Leading Constraint의 차이점을 설명하시오.**
   - **답변:** `Left Constraint`는 뷰의 왼쪽 가장자리에 대한 제약을 나타내고, `Leading Constraint`는 사용자의 언어 방향을 고려하여 왼쪽 또는 오른쪽 가장자리에 대한 제약을 나타냅니다. 대부분의 경우에는 Left와 Leading이 동일하게 작동하지만 RTL(Right-to-Left) 언어의 경우 Leading은 오른쪽으로 이동합니다.

**7. Auto Layout과 Frame-based Layout의 차이점은 무엇인가요?**
   - **답변:** `Auto Layout`은 제약을 사용하여 유연하고 다양한 디바이스 크기 및 방향에 대응하는 반면, `Frame-based Layout`은 직접 프레임을 설정하여 UI를 배치하는 방식입니다. Auto Layout은 화면 크기의 변화에 유연하게 대응할 수 있지만, 복잡한 제약 설정으로 인한 성능 저하가 있을 수 있습니다. Frame-based Layout은 직관적이지만, 여러 디바이스에 대응하기 어렵습니다.

## Debugging Tools
**1. 성능 향상을 위해 어떤 디버깅 도구를 사용할 수 있나요? 각각의 디버깅 도구는 어떤 상황에서 사용하는 것이 좋나요?**
   - **답변:** `Instruments`를 사용하여 메모리 사용량, CPU 사용량, 네트워크 활동 등을 모니터링할 수 있습니다. `Debug View Hierarchy`는 뷰 계층 구조를 확인하여 레이아웃 이슈를 해결하는 데 도움이 되며, `Time Profiler`는 코드 실행 시간을 분석하여 성능 개선에 활용할 수 있습니다. 이 도구들은 성능 문제를 찾고 해결하는 데에 유용하며, 특히 앱이 느리게 동작할 때 적절하게 사용됩니다.

## Swift
1. **struct와 class와 enum의 차이를 설명하시오.**
- 구조체(struct)는 값 타입이며 복사할 때 값이 복사됩니다. 상속이 불가능하며 주로 간단한 데이터 모델링에 사용됩니다. 클래스(class)는 참조 타입이며 복사할 때는 참조만 복사됩니다. 상속이 가능하며 주로 객체 지향 프로그래밍에서 사용됩니다. 열거형(enum)은 유한한 타입으로 명명된 값의 그룹을 정의합니다.

2. **class의 성능을 향상 시킬수 있는 방법들을 나열해보시오.**
- 지연 초기화, 결과 캐싱, 불필요한 상속 제거, 효율적 데이터 구조 선택, 비동기 프로그래밍 활용 등

3. **Copy On Write는 어떤 방식으로 동작하는지 설명하시오.**
- 값이 변경되기 전에는 주소값만 참조하며 실제 값이 변경되면 복사가 발생하는 최적화 기법입니다. 데이터를 공유하지만 변경이 필요할 때만 복사를 수행하여 메모리를 절약하고 성능을 향상시킵니다.

4. **Convenience init에 대해 설명하시오.**
- Convenience init은 클래스의 초기화 과정을 간편하게 도와주는 보조 이니셜라이저입니다. 다른 이니셜라이저를 호출하여 초기화 작업을 수행하고, 초기화 과정을 간소화할 수 있습니다.

5. **AnyObject에 대해 설명하시오.**
- AnyObject는 모든 클래스의 인스턴스를 나타내는 프로토콜 타입입니다. AnyObject를 사용하면 어떤 클래스의 인스턴스든 할당할 수 있으며, Swift의 클래스 타입은 모두 AnyObject 프로토콜을 따르므로 다형성을 지원합니다.

6. **Optional 이란 무엇인지 설명하시오.**
- Optional은 값이 있을 수도 있고, 없을 수도 있는 상태를 나타내는 타입입니다. 값이 있는 경우에는 해당 값을 갖고, 값이 없는 경우에는 nil을 갖습니다. Optional을 사용하여 안전하게 값의 존재 여부를 확인하고 처리할 수 있습니다.
  
7. **Struct가 무엇이고 어떻게 사용하는지 설명하시오.**
- Struct(구조체)는 값 타입으로, 연관된 데이터를 그룹화하여 표현하는 Swift의 기본 타입 중 하나입니다. 프로퍼티와 메서드를 포함할 수 있으며, 상속이 불가능하고 복사 시 값이 복사됩니다. 주로 간단한 데이터 모델링이나 데이터 유형을 표현할 때 사용됩니다.

8. **Subscripts에 대해 설명하시오.**
- Subscripts는 객체의 특정 요소에 접근하는 방법을 제공하는 기능입니다. 배열이나 딕셔너리와 같이 다양한 타입의 컬렉션에서 특정 요소에 접근할 때 사용됩니다. 인스턴스 이름 뒤에 대괄호를 사용하여 호출하며, getter와 setter를 정의할 수 있습니다.

9. **String은 왜 subscript로 접근이 안되는지 설명하시오.**
- String은 구조체이며, subscript로 인덱스를 통한 접근을 지원하지 않습니다. 이는 String이 다양한 유니코드 문자들을 포함하고 있어 각 문자의 길이가 일정하지 않기 때문입니다. 문자에 대한 접근은 String의 메서드를 통해 수행해야 합니다.

10. **instance 메서드와 class 메서드의 차이점을 설명하시오.**
- **instance 메서드**: 인스턴스에 속하는 메서드로, 해당 클래스나 구조체의 인스턴스를 생성한 후에 호출할 수 있습니다. 인스턴스의 프로퍼티에 접근할 수 있습니다.
- **class 메서드**: 클래스 또는 구조체 자체에 속하는 메서드로, 인스턴스를 생성하지 않고도 호출할 수 있습니다. 클래스 프로퍼티에 접근할 수 있지만, 인스턴스 프로퍼티에는 접근할 수 없습니다.

11. **class 메서드와 static 메서드의 차이점을 설명하시오.**
- **class 메서드**: 서브클래스에서 override할 수 있는 메서드. 상속된 클래스의 메서드를 재정의할 수 있습니다.
- **static 메서드**: 서브클래스에서 override할 수 없는 메서드. 재정의할 수 없고, 컴파일 시점에 결정됩니다.

12. **Delegate 패턴을 활용하는 경우를 예를 들어 설명하시오.**
- TableView나 CollectionView의 데이터 소스(delegate)를 구현하여 데이터를 제공하는 경우.
- 텍스트 필드의 입력을 처리하고 결과를 알리기 위해 UITextFieldDelegate를 사용하는 경우.

13. **Singleton 패턴을 활용하는 경우를 예를 들어 설명하시오.**
- 앱 내에서 공유되는 설정 관리 객체.
- 로그를 기록하고 관리하는 Logger 클래스.
  
14. **KVO 동작 방식에 대해 설명하시오.**
- KVO(Key-Value Observing)는 객체의 속성 변화를 감지하기 위해 사용되는 Cocoa 프로그래밍의 기능입니다.
- 등록된 객체는 관찰하고 있는 속성의 변화를 Observer에게 알려줍니다. 속성이 변경될 때마다 Observer에게 알림을 보내고, 등록된 Observer는 이를 처리할 수 있습니다.

15. **Delegates와 Notification 방식의 차이점에 대해 설명하시오.**
- **Delegates**: 일대일 관계. 객체 간의 특정 상호 작용을 위해 사용됩니다. 프로토콜을 통해 두 객체 간의 인터페이스를 정의합니다.
- **Notification**: 일대다 관계. 여러 객체에게 이벤트를 알리고자 할 때 사용됩니다. Notification Center를 통해 이벤트를 발송하고 수신할 수 있습니다.

16. **멀티 쓰레드로 동작하는 앱을 작성하고 싶을 때 고려할 수 있는 방식들을 설명하시오.**
- GCD(Grand Central Dispatch)를 사용하여 쓰레드 관리와 작업 스케줄링을 수행합니다.
- Operation Queue를 사용하여 작업을 관리하고 의존성을 설정합니다.
- 동기화 기법을 사용하여 여러 쓰레드에서 공유 데이터에 접근하는 것을 방지합니다.

17. **MVC 구조에 대해 블록 그림을 그리고, 각 역할과 흐름을 설명하시오.**
![MVC](https://developer.mozilla.org/ko/docs/Glossary/MVC/model-view-controller-light-blue.png)
- Model: 데이터 구조를 정의
- View: 디스플레이(UI)를 정의
  - 예) 장바구니에 추가 버튼을 화면에 추가
- Controller: 뷰로부터 입력 정보 등을 받고 그것을 모델에 알려주는 역할

18. **프로토콜이란 무엇인지 설명하시오.**
- 프로토콜은 특정 작업 또는 기능을 수행하기 위해 필요한 메서드, 프로퍼티 및 기타 요구사항의 청사진입니다. 클래스, 구조체 또는 열거형에서 프로토콜을 채택하여 요구사항을 구현할 수 있습니다.

19. **Protocol Oriented Programming과 Object Oriented Programming의 차이점을 설명하시오.**
- **Object Oriented Programming**: 객체 지향 프로그래밍은 클래스를 중심으로 객체를 모델링하고 상속, 캡슐화, 다형성을 활용하여 프로그램을 작성합니다.
- **Protocol Oriented Programming**: 프로토콜을 중심으로 데이터와 기능을 정의하고, 프로토콜을 채택하여 구현함으로써 코드의 재사용성과 유연성을 높이는 프로그래밍 접근 방식입니다.

20. **Hashable이 무엇이고, Equatable을 왜 상속해야 하는지 설명하시오.**
- **Hashable**: 객체를 해시값으로 매핑하기 위해 사용되는 프로토콜. 집합(Set)이나 딕셔너리(Dictionary)에 저장하기 위해서 필요합니다.
- **Equatable**: 객체가 동등한지를 비교하기 위한 프로토콜. == 연산자를 사용하여 두 객체를 비교할 수 있도록 해줍니다.

21. **mutating 키워드에 대해 설명하시오.**
- **mutating**: 구조체나 열거형 내부에서 해당 인스턴스의 프로퍼티를 변경할 때 사용되는 키워드. 값 타입에서 메서드가 프로퍼티를 변경할 수 있도록 허용합니다.

22. **탈출 클로저에 대하여 설명하시오.**
- **탈출 클로저**: 함수가 종료된 후에도 실행되거나 다른 변수에 저장될 수 있는 클로저. 일반적으로 비동기 작업에서 사용됩니다.

23. **Extension에 대해 설명하시오.**
- **Extension**: 기존 클래스, 구조체, 열거형 등에 새로운 기능을 추가하는 방법. 확장을 통해 프로토콜 준수, 계산된 프로퍼티, 초기화, 메서드 등을 추가할 수 있습니다.

24. **Extension 내부에서 함수를 override할 수 있는지 설명하시오.**
- Extension 내부에서는 기존 클래스나 구조체의 함수를 override할 수 없습니다. Extension은 해당 타입의 기능을 확장하는 용도로 사용되므로, 서브클래싱과 관련된 override는 불가능합니다.

25. **접근 제어자의 종류엔 어떤게 있는지 설명하시오.**
 - **private**: 선언한 파일 내에서만 접근 가능.
 - **fileprivate**: 선언한 파일 내의 모든 위치에서 접근 가능.
 - **internal**: 같은 모듈 내에서 접근 가능(기본 접근 수준).
 - **public**: 모듈 외부에서도 접근 가능.
 - **open**: 모듈 외부에서 접근 가능하고, 다른 모듈에서 상속 가능.

26. **defer란 무엇인지 설명하시오.**
 - **defer**: 코드 블록의 실행을 현재 범위가 종료되기 전까지 연기시키는 키워드. 주로 리소스의 정리나 임시적인 작업을 위해 사용됩니다.

27. **defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우를 설명하시오.**
 - defer는 코드 블록의 종료 직전에 실행되며, 스택(Stack) 방식으로 호출됩니다. defer 블록 내에서 예외가 발생하거나 해당 블록이 실행되지 않는다면 defer는 호출되지 않습니다.

28. **property wrapper에 대해서 설명하시오.**
 - **property wrapper**: 프로퍼티를 감싸고 캡슐화하여 추가 동작을 제공하는 기능. 커스텀 프로퍼티를 생성하고, 프로퍼티에 접근할 때 추가 로직을 수행할 수 있습니다.

29. **Generic에 대해 설명하시오.**
 - **Generic**: 타입을 인자로 받아서 코드를 작성할 수 있도록 해주는 기능. 타입에 의존하지 않는 유연한 코드를 작성할 수 있습니다.

30. **some 키워드에 대해 설명하시오.**
 - **some**: Opaque Return Type(불투명 반환 타입)을 선언할 때 사용되는 키워드. 특정 타입의 구체적인 세부 내용을 감추고, 일부 조건을 만족하는 유형을 나타냅니다.

31. **Result타입에 대해 설명하시오.**
 - **Result 타입**: 비동기 작업의 성공 또는 실패를 표현하기 위해 사용되는 열거형. 성공 시 연관 값을 포함하고, 실패 시 에러 값을 포함합니다.

32. **Codable에 대하여 설명하시오.**
 - **Codable**: Swift에서 제공하는 프로토콜로, 데이터를 인코딩(Encode)하거나 디코딩(Decode)할 수 있는 타입을 나타냅니다. JSON과 같은 외부 데이터 포맷을 다룰 때 유용합니다.

33. **Closure에 대하여 설명하시오.**
 - **Closure**: 이름이 없는 함수로, 코드 블록을 변수로 저장하거나 전달할 수 있는 기능입니다. 주로 콜백(Callback)이나 비동기 작업에서 사용됩니다.

34. **Closure와 함수와의 관계에 대해 설명하시오.**
 - Closure는 함수의 일종으로, 이름이 없는 익명 함수입니다. 함수처럼 동작하며 변수에 할당하거나 인자로 전달할 수 있습니다.

35. **Optional Chaining과 nil-coalescing operator(`??`)의 차이점과 사용 시 주의사항은 무엇인가요?**
 - **Optional Chaining**: 옵셔널 값의 연쇄적인 호출을 간편하게 수행할 수 있는 기능. 호출 중 하나라도 nil이면 전체 표현식이 nil을 반환합니다.
 - **nil-coalescing operator(??)**: 옵셔널 값이 nil일 때 대체 값을 제공하는 연산자. 옵셔널 값이 nil이 아니면 옵셔널을 해제하고, nil이면 대체 값으로 대체합니다. 주의사항은 대체 값이 옵셔널이 아니어야 합니다.

36. **Swift에서 Async/Await 기능이 도입되기 전에, 비동기(Asynchronous) 작업을 처리하는 방법에는 어떤 것들이 있나요?**
 - GCD(Grand Central Dispatch)를 사용하여 백그라운드 스레드에서 작업을 수행합니다.
 - Completion Handler나 Delegate를 사용하여 비동기 작업의 완료를 처리합니다.
 - Operation Queue를 사용하여 작업을 관리하고 의존성을 설정합니다.

37. **타입 변환(Type Casting)과 다형성(Polymorphism)에 대해 설명해보세요.**
 - **타입 변환(Type Casting)**: 객체의 타입을 다른 타입으로 변환하는 것을 의미합니다. 상위 클래스로부터 하위 클래스로의 변환(Casting)이 가능합니다.
 - **다형성(Polymorphism)**: 동일한 메서드 호출이 서로 다른 클래스에 의해 다르게 처리되는 것을 의미합니다. 상속을 통해 구현됩니다.

38. **Swift에서 타입 안전성(type safety)은 어떤 방식으로 보장되나요?**
 - Swift는 정적 타입 언어로, 컴파일 시점에 타입 안전성을 보장합니다.
 - 컴파일러가 타입 일치를 강제하고, 올바르지 않은 타입 사용 시 경고 또는 에러를 발생시킵니다.

## ARC
- ARC란 무엇인지 설명하시오.
- Retain Count 방식에 대해 설명하시오.
- Strong 과 Weak 참조 방식에 대해 설명하시오.
- 순환 참조에 대하여 설명하시오.
- 강한 순환 참조 (Strong Reference Cycle) 는 어떤 경우에 발생하는지 설명하시오.

## Functional Programming
- 순수함수란 무엇인지 설명하시오.
- 함수형 프로그래밍이 무엇인지 설명하시오.
- 고차 함수가 무엇인지 설명하시오.
- Swift Standard Library의 map, filter, reduce, compactMap, flatMap에 대하여 설명하시오.
- Either type이란?

## Architecture
- MVVM, MVI, Ribs, VIP 등 자신이 알고있는 아키텍쳐를 설명하시오.
- 의존성 주입에 대하여 설명하시오.

## SwiftUI
**1. @State가 어떻게 동작하는지 설명하시오.**
   - **답변:** `@State`는 SwiftUI에서 사용되는 프로퍼티 래퍼로, 뷰의 상태를 나타내는 데에 사용됩니다. `@State`로 선언된 변수의 변경이 감지되면 해당 뷰가 자동으로 다시 그려지고 업데이트됩니다. 주로 뷰의 내부 상태를 저장하고, 해당 상태가 변경될 때마다 뷰를 갱신하는 데에 활용됩니다. 또한 `@State` 프로퍼티는 뷰의 생명주기 동안 보존되어 값의 변경이 지속적으로 관찰됩니다.

## Combine
**1. PassthroughSubject에 대해서 설명하시오**
   - **답변:** `PassthroughSubject`는 Combine 프레임워크에서 제공하는 Subject 중 하나로, 값을 발행하고 구독자들에게 전달하는 역할을 합니다. 값을 내보내는 데 사용되며, 새로운 값을 내보내면 현재 구독 중인 모든 구독자에게 해당 값을 전달합니다.

**2. @Published에 대해서 설명하시오**
   - **답변:** `@Published`는 Swift의 프로퍼티 래퍼(wrapper) 중 하나로, Combine 프레임워크와 함께 사용되어 프로퍼티의 변경을 자동으로 감지하고 해당 변경을 구독자들에게 알립니다. 주로 Observable Object 클래스에서 상태를 감지하고 변경 사항을 뷰에 반영할 때 사용됩니다.

**3. AnyCancellable에 대해서 설명하시오**
   - **답변:** `AnyCancellable`은 Combine에서 제공하는 구독을 나타내는 타입으로, 구독을 취소하거나 제거하는 데 사용됩니다. Combine에서 비동기적인 작업을 수행하고 그 결과를 처리할 때 반환되는 구독을 AnyCancellable로 저장하고, 해당 구독을 취소함으로써 메모리 누수를 방지할 수 있습니다.

**4. sink에 대해서 설명하시오**
   - **답변:** `sink`는 Combine에서 사용되는 연산자 중 하나로, Publisher에서 값을 받아와서 처리하는 역할을 합니다. 주로 구독자(Subscriber)를 생성하고 값을 처리하는 클로저를 제공하여 사용됩니다. sink 연산자를 통해 값을 받아올 때마다 클로저가 실행되어 해당 값을 처리하게 됩니다.

**5. throttle과 debounce의 차이점을 설명하시오.**
   - **답변:** `throttle`과 `debounce`는 둘 다 이벤트의 발생 간격을 제어하는데 사용되는 Combine 연산자입니다. 하지만 차이점은 다음과 같습니다. `throttle`은 최초 이벤트가 발생하면 지정된 시간 동안 다른 이벤트를 무시하고, 그 후에 다음 이벤트를 받아옵니다. 반면에 `debounce`는 이벤트가 발생한 후 지정된 시간 동안 다른 이벤트가 없을 때에만 해당 이벤트를 받아옵니다.

**6. Data를 Binding하는 방법에 대해서 설명하시오.**
   - **답변:** SwiftUI에서 `Data`를 바인딩하는 방법은 `@Binding`을 사용하는 것입니다. `@Binding`은 부모 뷰에서 자식 뷰로 데이터를 전달하고, 자식 뷰에서 해당 데이터를 수정할 수 있도록 하는 데에 사용됩니다. 이를 통해 뷰 간에 양방향 데이터 흐름을 구현할 수 있습니다. 바인딩된 데이터가 변경되면 해당 변경이 뷰에 자동으로 반영됩니다.

## Concurrency
### GCD, NSOperation
- NSOperationQueue 와 GCD Queue 의 차이점을 설명하시오.
- GCD API 동작 방식과 필요성에 대해 설명하시오.
- Global DispatchQueue 의 Qos 에는 어떤 종류가 있는지, 각각 어떤 의미인지 설명하시오.

### Swift Concurrency
**1. @MainActor는 언제 이용하는가?**
   - **답변:** `@MainActor`는 Swift Concurrency 모델에서 비동기적인 코드를 메인 스레드에서 실행하도록 하는 속성입니다. 주로 비동기 작업에서 UI 업데이트나 메인 스레드에서 실행되어야 하는 코드 블록에 사용됩니다. `@MainActor` 속성을 가진 함수나 클로저는 자동으로 메인 스레드에서 실행되므로 UI 업데이트를 안전하게 수행할 수 있습니다.

**2. task 동작 방식과 GCD, NSOperation과의 차이점을 설명하시오.**
   - **답변:** `task`는 Swift Concurrency에서 제공하는 비동기 작업을 수행하는 새로운 방식입니다. GCD(Grand Central Dispatch) 및 NSOperation과의 차이점은 다음과 같습니다.
     - `task`는 구조적이며 간결한 문법을 제공하며, 비동기 코드를 동기적인 코드처럼 작성할 수 있습니다.
     - GCD 및 NSOperation은 콜백이나 완료 핸들러를 사용하는 반면, `task`는 `await` 키워드를 사용하여 비동기 작업의 완료를 기다릴 수 있습니다.
     - `task`는 자동으로 적절한 수준의 스레드 관리를 수행하므로 개발자가 직접 스레드를 관리할 필요가 없습니다.

# Optional
아래부터는 추가로 공부를 하면 좋을 내용들입니다.

<details>
  <summary>접기/펼치기</summary>
  
## Rx
- Reactive Programming이 무엇인지 설명하시오.
- RxSwift를 왜 사용하는지 설명하시오.
- RxSwift의 단점을 설명하시오.
- RxSwift에서 Hot Observable과 Cold Observable의 차이를 설명하시오.
- Subject의 종류와 차이점에 대해 설명하시오.
- Subject와 Driver의 차이를 설명하시오.
- Single, Completable, Maybe의 차이점에 대해 설명하고, 언제 적용하면 좋을지 설명하시오.

## MRC
- ARC 대신 Manual Reference Count 방식으로 구현할 때 꼭 사용해야 하는 메서드들을 쓰고 역할을 설명하시오.
- retain 과 assign 의 차이점을 설명하시오.
- 특정 객체를 autorelease 하기 위해 필요한 사항과 과정을 설명하시오.
- Autorelease Pool을 사용해야 하는 상황을 두 가지 이상 예로 들어 설명하시오. 
- 다음 코드를 실행하면 어떤 일이 발생할까 추측해서 설명하시오.
Ball *ball = [[[[Ball alloc] init] autorelease] autorelease];

## Advanced
- method swizzling이 무엇이고, 어떨 때 사용하는지 설명하시오.
- NSCoder 클래스는 어떤 상황에서 어떻게 써야 하는지 설명하시오.
- Responder Chain 구조에 대해 설명하고, First Responder 역할에 대해 설명하시오.
- NSObject부터 UIButton 까지 상속 과정의 계층과 역할을 설명하시오.
- shallow copy와 deep copy의 차이점을 설명하시오.
- Push Notification 방식에 대해 설명하시오.
- Foundation 과 Core Foundation 프레임워크의 차이점을 설명하시오.
- NSURLConnection 에서 사용하는 Delegate 메서드들에 대해 설명하시오.
- Synchronous 방식과 Asynchronous 방식으로 URL Connection을 처리할 경우의 장단점을 비교하시오.
- Plist 파일 구조와 Plist 파일에 저장된 데이터를 다루기 적합한 클래스를 설명하시오.
- Core Data와 Sqlite 같은 데이터 베이스의 차이점을 설명하시오.
- JSON 데이터를 처리하는 방식과 파서, 객체 변환 방식에 대해 설명하시오.
- 웹 서버와 HTTP 연결을 사용해서 데이터를 주거나 받으려면 사용해야 하는 클래스와 동작을 설명하시오.
- Protocol에서는 왜 var만 되는지 설명하시요.
- DispatchQueue.main.sync를 사용하는 상황을 설명하시오.
- Run Loops에 대해 설명하시오.

## Objective-C
- Swift의 클로저와 Objective-C의 블록은 어떤 차이가 있는가?
- Mutable 객체과 Immutable 객체는 어떤것이 있는지 예를 들고, 차이점을 설명하시오.
- dynamic과 property 의미와 차이를 설명하시오.
- @property로 선언한 NSString* title 의 getter/setter 메서드를 구현해보시오.
- @property에서 atomic과 nonatomic 차이점을 설명하고, 어떤것이 안전한지, 어느것이 기본인지 설명하시오.
- @property로 선언한다는 것의 의미를 설명하고, .h에 넣을 경우와 .m에 넣을 경우 차이점을 설명하시오.
- -performSelector:withObject:afterDelay: 메시지를 보내면 인자값의 객체는 retain되는가? 그 이유를 함께 설명하시오.
- Objective-C 에서 캡슐화된 데이터를 접근하기 위한 방법들을 설명하시오.
- Fast Enumeration 이란 무엇인지 설명하시오. 
- unnamed category 방식에 대해 설명하시오.
- Category 확장과 Subclass 확장의 차이점을 설명하시오.
- Category 방식에 대해 설명하시오.
- Objective-C 에서 Protocol 이란 무엇인지 설명하시오.
- Objective-C++ 방식이 무엇인지 설명하고, 어떤 경우 사용해야 하는지 설명하시오.
</details>

